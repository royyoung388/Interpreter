program -> statements
statements -> statement statements
statements -> $

statement -> declare_stm ;
statement -> assign_stm ;
statement -> while_stm
statement -> do_stm
statement -> for_stm
statement -> if_stm
statement -> switch_stm

num -> INT
num -> REAL
value -> num
value -> CHAR

expression -> arithmetic_exp
expression -> logic_exp

arithmetic_exp -> arithmetic_item item_op
item_op -> BIN_AR_OP_2 arithmetic_item
item_op -> $
arithmetic_item -> arithmetic_fac fac_op
fac_op -> BIN_AR_OP_1 arithmetic_fac
fac_op -> $
arithmetic_fac -> num
arithmetic_fac -> ID
arithmetic_fac -> ( arithmetic_exp )

logic_exp -> arithmetic_exp LOGIC_OP arithmetic_exp
logic_exp -> 1
logic_exp -> 0

declare_stm -> TYPE declare_ass
declare_ass -> declare_ass , declare_ass
declare_ass -> ID ASS_OP expression
declare_ass -> ID
declare_ass -> ID [ INT ] = declare_arr
declare_ass -> ID [ ] = declare_arr
declare_arr -> { arr_item }
declare_arr -> { arr_item , arr_item }
arr_item -> { value }

assign_stm -> ID ASS_OP expression
assign_stm -> SELF_OP ID
assign_stm -> ID SELF_OP
assign_stm -> ID [ INT ] ASS_OP expression

while_stm -> while ( logic_exp ) { statements }
do_stm -> do { statements } while ( logic_exp ) ;
for_stm -> for ( assign_stm ; logic_exp ; assign_stm ) { statements }
if_stm -> if ( logic_exp ) { statements } else_stm
else_stm -> $
else_stm -> else else_if
else_if -> if_stm
else_if -> { statements }


program	:	statement+;

statement:	if_stm | while_stm | read_stm | write_stm | assign_stm | declare_stm;

if_stm	:	IF LPAREN condition RPAREN LBRACE statement RBRACE (ELSE LBRACE statement RBRACE)?;

while_stm:	WHILE LPAREN condition RPAREN LBRACE statement RBRACE;

read_stm:	READ LPAREN ID RPAREN SEMICOLON;

write_stm:	WRITE LPAREN expression RPAREN SEMICOLON;

assign_stm:	(ID | ID array) ASSIGN expression SEMICOLON;

declare_stm:	(INT | REAL | BOOL | BOOL array | INT array | REAL array) ID(COMMA ID)* SEMICOLON;

condition	:	expression comparison_op expression;

expression:	term (add_op term)*;

term	:	factor (mul_op factor)*;

comparison_op :	LT | GT | EQUAL | NEQUAL;

add_op	:	PLUS | MINUS;

mul_op	:	TIMES | DIVIDE;

factor	:	REAL_LITERAL | INTEGER_LITERAL | ID | LPAREN expression RPAREN | ID array;

array 	:	LBRACKET (INTEGER_LITERAL | ID) RBRACKET;

READ	:	'read';
WRITE	:	'write';
WHILE	:	'while';
IF	:	'if';
ELSE	:	'else';
INT	:	'int';
REAL	:	'real';
BOOL	:	'bool';
SEMICOLON :	';';
LPAREN	:	'(';
RPAREN	:	')';
LBRACE	:	'{';
RBRACE	:	'}';
LBRACKET:	'[';
RBRACKET:	']';
COMMA	:	',';
ASSIGN	:	'=';
PLUS	:	'+';
MINUS	:	'-';
TIMES	:	'*';
DIVIDE	:	'/';
LT	:	'<';
GT	:	'>';
EQUAL	:	'==';
NEQUAL	:	'<>';
ROW	:	'//';
LEFT	:	'/*';
RIGHT	:	'*/';
LETTER	:	('a'..'z'|'A'..'Z');
DIGIT	:	('0'..'9');
ID	:	LETTER ((LETTER | DIGIT | '_')*(LETTER | DIGIT))?;
INTEGER_LITERAL :	('1'..'9')('0'..'9')*|'0';
REAL_LITERAL :	(INTEGER_LITERAL)('.'(INTEGER_LITERAL)+)?;

NEWLINE:'\r'? '\n';
WS  :   (' '|'\t')+ {skip();};

S -> func funcs
funcs -> func funcs
funcs -> $
func -> type IDN ( args ) func_body
type -> int
type -> short
type -> long
type -> char
type -> float
type -> double
type -> void
type -> unsigned type
args -> type IDN arg
args -> $
arg -> , type IDN arg
arg -> $
func_body -> ;
func_body -> block
block -> { define_stmts stmts }
define_stmts -> define_stmt define_stmts
define_stmts -> $
define_stmt -> type IDN init vars ;
init -> = expression
init -> $
vars -> , IDN init vars
vars -> $
stmts -> stmt stmts
stmts -> $
stmt -> assign_stmt
stmt -> jump_stmt
stmt -> iteration_stmt
stmt -> branch_stmt
assign_stmt -> expression ;
jump_stmt -> continue ;
jump_stmt -> break ;
jump_stmt -> return isnull_expr ;
iteration_stmt -> while ( logical_expression ) block_stmt
iteration_stmt -> for ( isnull_expr ; isnull_expr ; isnull_expr ) block_stmt
iteration_stmt -> do block_stmt while ( logical_expression ) ;
branch_stmt -> if ( logical_expression ) block_stmt result
result -> else block_stmt
result -> $
logical_expression -> ! expression bool_expression
logical_expression -> expression bool_expression
bool_expression -> lop expression bool_expression
bool_expression -> $
lop -> &&
lop -> ||
branch_stmt -> switch ( IDN ) { case_stmt case_stmts default_stmt }
case_stmts -> case_stmt case_stmts
case_stmts -> $
case_stmt -> case const : stmts
default_stmt -> default : stmts
block_stmt -> { stmts }
isnull_expr -> expression
isnull_expr -> $
expression -> value operation
operation -> compare_op value
operation -> equal_op value
operation -> $
compare_op -> >
compare_op -> >=
compare_op -> <
compare_op -> <=
compare_op -> ==
compare_op -> !=
equal_op -> =
equal_op -> +=
equal_op -> -=
equal_op -> *=
equal_op -> /=
equal_op -> %=
value -> item value'
value' -> + item value'
value' -> - item value'
value' -> $
item -> factor item'
item' -> * factor item'
item' -> / factor item'
item' -> % factor item'
item' -> $
factor -> ( value )
factor -> IDN call_func
factor -> const
call_func -> ( es )
call_func -> $
es -> isnull_expr isnull_es
isnull_es -> , isnull_expr isnull_es
isnull_es -> $
const -> num_const
const -> FLOAT
const -> CHAR
const -> STR
num_const -> INT10
num_const -> INT8
num_const -> INT16